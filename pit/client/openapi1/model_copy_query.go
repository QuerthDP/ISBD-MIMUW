/*
MIMUW ISBD database system

This file describes interface between DBMS system and user.

API version: 1.0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi1

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the CopyQuery type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &CopyQuery{}

// CopyQuery Description of the COPY query from CSV file. Server will read the file and insert all data into selected table. When number of columns in source and target doesn't match, user have to use \"destinationColumns\" property to specify which columns data should be inserted into.
type CopyQuery struct {
	// Path to source CSV file (filepath in perspective of running server! NOT client)
	SourceFilepath string `json:"sourceFilepath"`
	DestinationTableName string `json:"destinationTableName"`
	// List of columns to copy data into. It creates a map from source columns to destination columns. Assumes that data in source file is in the same order as in this list.
	DestinationColumns []string `json:"destinationColumns,omitempty"`
	// Whether CSV file contains header row
	DoesCsvContainHeader *bool `json:"doesCsvContainHeader,omitempty"`
}

type _CopyQuery CopyQuery

// NewCopyQuery instantiates a new CopyQuery object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewCopyQuery(sourceFilepath string, destinationTableName string) *CopyQuery {
	this := CopyQuery{}
	this.SourceFilepath = sourceFilepath
	this.DestinationTableName = destinationTableName
	var doesCsvContainHeader bool = false
	this.DoesCsvContainHeader = &doesCsvContainHeader
	return &this
}

// NewCopyQueryWithDefaults instantiates a new CopyQuery object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewCopyQueryWithDefaults() *CopyQuery {
	this := CopyQuery{}
	var doesCsvContainHeader bool = false
	this.DoesCsvContainHeader = &doesCsvContainHeader
	return &this
}

// GetSourceFilepath returns the SourceFilepath field value
func (o *CopyQuery) GetSourceFilepath() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.SourceFilepath
}

// GetSourceFilepathOk returns a tuple with the SourceFilepath field value
// and a boolean to check if the value has been set.
func (o *CopyQuery) GetSourceFilepathOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.SourceFilepath, true
}

// SetSourceFilepath sets field value
func (o *CopyQuery) SetSourceFilepath(v string) {
	o.SourceFilepath = v
}

// GetDestinationTableName returns the DestinationTableName field value
func (o *CopyQuery) GetDestinationTableName() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.DestinationTableName
}

// GetDestinationTableNameOk returns a tuple with the DestinationTableName field value
// and a boolean to check if the value has been set.
func (o *CopyQuery) GetDestinationTableNameOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.DestinationTableName, true
}

// SetDestinationTableName sets field value
func (o *CopyQuery) SetDestinationTableName(v string) {
	o.DestinationTableName = v
}

// GetDestinationColumns returns the DestinationColumns field value if set, zero value otherwise.
func (o *CopyQuery) GetDestinationColumns() []string {
	if o == nil || IsNil(o.DestinationColumns) {
		var ret []string
		return ret
	}
	return o.DestinationColumns
}

// GetDestinationColumnsOk returns a tuple with the DestinationColumns field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *CopyQuery) GetDestinationColumnsOk() ([]string, bool) {
	if o == nil || IsNil(o.DestinationColumns) {
		return nil, false
	}
	return o.DestinationColumns, true
}

// HasDestinationColumns returns a boolean if a field has been set.
func (o *CopyQuery) HasDestinationColumns() bool {
	if o != nil && !IsNil(o.DestinationColumns) {
		return true
	}

	return false
}

// SetDestinationColumns gets a reference to the given []string and assigns it to the DestinationColumns field.
func (o *CopyQuery) SetDestinationColumns(v []string) {
	o.DestinationColumns = v
}

// GetDoesCsvContainHeader returns the DoesCsvContainHeader field value if set, zero value otherwise.
func (o *CopyQuery) GetDoesCsvContainHeader() bool {
	if o == nil || IsNil(o.DoesCsvContainHeader) {
		var ret bool
		return ret
	}
	return *o.DoesCsvContainHeader
}

// GetDoesCsvContainHeaderOk returns a tuple with the DoesCsvContainHeader field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *CopyQuery) GetDoesCsvContainHeaderOk() (*bool, bool) {
	if o == nil || IsNil(o.DoesCsvContainHeader) {
		return nil, false
	}
	return o.DoesCsvContainHeader, true
}

// HasDoesCsvContainHeader returns a boolean if a field has been set.
func (o *CopyQuery) HasDoesCsvContainHeader() bool {
	if o != nil && !IsNil(o.DoesCsvContainHeader) {
		return true
	}

	return false
}

// SetDoesCsvContainHeader gets a reference to the given bool and assigns it to the DoesCsvContainHeader field.
func (o *CopyQuery) SetDoesCsvContainHeader(v bool) {
	o.DoesCsvContainHeader = &v
}

func (o CopyQuery) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o CopyQuery) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["sourceFilepath"] = o.SourceFilepath
	toSerialize["destinationTableName"] = o.DestinationTableName
	if !IsNil(o.DestinationColumns) {
		toSerialize["destinationColumns"] = o.DestinationColumns
	}
	if !IsNil(o.DoesCsvContainHeader) {
		toSerialize["doesCsvContainHeader"] = o.DoesCsvContainHeader
	}
	return toSerialize, nil
}

func (o *CopyQuery) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"sourceFilepath",
		"destinationTableName",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varCopyQuery := _CopyQuery{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varCopyQuery)

	if err != nil {
		return err
	}

	*o = CopyQuery(varCopyQuery)

	return err
}

type NullableCopyQuery struct {
	value *CopyQuery
	isSet bool
}

func (v NullableCopyQuery) Get() *CopyQuery {
	return v.value
}

func (v *NullableCopyQuery) Set(val *CopyQuery) {
	v.value = val
	v.isSet = true
}

func (v NullableCopyQuery) IsSet() bool {
	return v.isSet
}

func (v *NullableCopyQuery) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCopyQuery(val *CopyQuery) *NullableCopyQuery {
	return &NullableCopyQuery{value: val, isSet: true}
}

func (v NullableCopyQuery) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCopyQuery) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


