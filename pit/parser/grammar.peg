{
// Package parser provides SQL parsing for a subset of SQL
// that maps to the ISBD DBMS OpenAPI interface.
//
// This file is the source of truth for the SQL grammar.
// To regenerate the parser, run:
//   go generate ./...
//
// Grammar supports:
//   - SELECT with column expressions
//   - FROM clause (optional, table name is parsed but not stored)
//   - WHERE clause with boolean expressions
//   - ORDER BY clause (by column index, ASC/DESC)
//   - LIMIT clause
//   - Arithmetic operators: +, -, *, /
//   - Comparison operators: =, <>, !=, <, <=, >, >=
//   - Logical operators: AND, OR, NOT
//   - Functions: STRLEN, CONCAT, UPPER, LOWER
//   - Literals: integers, strings, TRUE, FALSE
//   - Column references: column or table.column

package parser

import (
    openapi "github.com/smogork/ISBD-MIMUW/pit/client"
)
}

// ============================================================================
// Entry Point
// ============================================================================

Query <- _ "SELECT"i _ columns:ColumnList from:FromClause? where:WhereClause? 
         orderBy:OrderByClause? limit:LimitClause? _ ';'? _ EOF {
    return buildQuery(columns, from, where, orderBy, limit), nil
}

// ============================================================================
// Clauses
// ============================================================================

ColumnList <- first:Expr rest:( _ ',' _ e:Expr { return e, nil } )* {
    return buildColumnList(first, rest), nil
}

FromClause <- _ "FROM"i _ name:Identifier {
    s := name.(string)
    return &s, nil
}

WhereClause <- _ "WHERE"i _ expr:Expr {
    return expr, nil
}

OrderByClause <- _ "ORDER"i _ "BY"i _ first:OrderByItem rest:( _ ',' _ o:OrderByItem { return o, nil } )* {
    return buildOrderByList(first, rest), nil
}

OrderByItem <- idx:Integer dir:( _ d:("ASC"i / "DESC"i) { return string(c.text), nil } )? {
    return buildOrderByItem(idx, dir), nil
}

LimitClause <- _ "LIMIT"i _ n:Integer {
    return buildLimitClause(n), nil
}

// ============================================================================
// Expressions (precedence from lowest to highest)
// ============================================================================

Expr <- OrExpr

OrExpr <- first:AndExpr rest:( _ "OR"i _ e:AndExpr { return e, nil } )* {
    return buildBinaryChain(first, rest, "OR"), nil
}

AndExpr <- first:Comparison rest:( _ "AND"i _ e:Comparison { return e, nil } )* {
    return buildBinaryChain(first, rest, "AND"), nil
}

Comparison <- left:Additive op:CompOp? right:Additive? {
    return buildComparison(left, op, right), nil
}

CompOp <- _ op:( "<=" / ">=" / "<>" / "!=" / "<" / ">" / "=" ) _ {
    return string(c.text), nil
}

Additive <- first:Multiplicative rest:( _ op:AddOp _ e:Multiplicative { return []interface{}{op, e}, nil } )* {
    return buildAdditiveChain(first, rest), nil
}

AddOp <- op:( '+' / '-' ) {
    return string(c.text), nil
}

Multiplicative <- first:Unary rest:( _ op:MulOp _ e:Unary { return []interface{}{op, e}, nil } )* {
    return buildMultiplicativeChain(first, rest), nil
}

MulOp <- op:( '*' / '/' ) {
    return string(c.text), nil
}

Unary <- op:UnaryOp? _ primary:Primary {
    return buildUnary(op, primary), nil
}

UnaryOp <- op:( "NOT"i / '-' ) _ {
    return string(c.text), nil
}

// ============================================================================
// Primary Expressions
// ============================================================================

Primary <- Literal / FunctionCall / ColumnRef / ParenExpr

ParenExpr <- '(' _ expr:Expr _ ')' {
    return expr, nil
}

Literal <- BoolLiteral / StringLiteral / IntLiteral

IntLiteral <- [0-9]+ {
    return buildIntLiteral(string(c.text)), nil
}

StringLiteral <- '\'' content:StringContent '\'' {
    return buildStringLiteral(content), nil
}

StringContent <- ( !'\'' . / "''" )* {
    return string(c.text), nil
}

BoolLiteral <- ( "TRUE"i / "FALSE"i ) {
    return buildBoolLiteral(string(c.text)), nil
}

FunctionCall <- name:FunctionName _ '(' _ args:FunctionArgs? _ ')' {
    return buildFunction(name, args), nil
}

FunctionName <- ( "STRLEN"i / "CONCAT"i / "UPPER"i / "LOWER"i ) {
    return string(c.text), nil
}

FunctionArgs <- first:Expr rest:( _ ',' _ e:Expr { return e, nil } )* {
    return buildArgsList(first, rest), nil
}

ColumnRef <- table:( name:Identifier '.' { return name, nil } )? column:Identifier {
    return buildColumnRef(table, column), nil
}

// ============================================================================
// Lexical Elements
// ============================================================================

Identifier <- !ReservedWord [a-zA-Z_] [a-zA-Z0-9_]* {
    return string(c.text), nil
}

ReservedWord <- ( "SELECT"i / "FROM"i / "WHERE"i / "ORDER"i / "BY"i / "ASC"i / "DESC"i / 
                 "LIMIT"i / "AND"i / "OR"i / "NOT"i / "TRUE"i / "FALSE"i /
                 "STRLEN"i / "CONCAT"i / "UPPER"i / "LOWER"i ) ![a-zA-Z0-9_]

Integer <- [0-9]+ {
    return parseInt(string(c.text)), nil
}

_ "whitespace" <- [ \t\n\r]*

EOF <- !.
