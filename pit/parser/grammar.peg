{
// Package parser provides SQL parsing for a subset of SQL
// that maps to the ISBD DBMS OpenAPI interface.
//
// This file is the source of truth for the SQL grammar.
// To regenerate the parser, run:
//   go generate ./...
//
// Grammar supports:
//   - SELECT with column expressions
//   - FROM clause (optional, table name is parsed but not stored)
//   - WHERE clause with boolean expressions
//   - ORDER BY clause (by column index, ASC/DESC)
//   - LIMIT clause
//   - Arithmetic operators: +, -, *, /
//   - Comparison operators: =, <>, !=, <, <=, >, >=
//   - Logical operators: AND, OR, NOT
//   - Functions: STRLEN, CONCAT, REPLACE, UPPER, LOWER
//   - Literals: integers, strings, TRUE, FALSE
//   - Column references: column or table.column

package parser

import (
    openapi "github.com/smogork/ISBD-MIMUW/pit/client/openapi2"
)
}

// ============================================================================
// Entry Point
// ============================================================================

// When FROM is missing => return error
Query <- _ SELECT_K _ columns:ColumnList _ EOF {
    return nil, fmt.Errorf("FROM clause is required")
}
/ _ SELECT_K _ columns:ColumnList from:FromClause where:WhereClause? 
         orderBy:OrderByClause? limit:LimitClause? _ ';'? _ EOF {
    return buildQuery(columns, from, where, orderBy, limit)
}

// ============================================================================
// Clauses
// ============================================================================

ColumnList <- first:Expr rest:( _ ',' _ e:Expr { return e, nil } )* {
    return buildColumnList(first, rest), nil
}

FromClause <- _ FROM_K _ first:Identifier rest:( _ ',' _ name:Identifier { return name, nil } )* {
    return buildFromClause(first, rest), nil
}

WhereClause <- _ WHERE_K _ expr:Expr {
    return expr, nil
}

OrderByClause <- _ ORDER_K _ BY_K _ first:OrderByItem rest:( _ ',' _ o:OrderByItem { return o, nil } )* {
    return buildOrderByList(first, rest), nil
}

OrderByItem <- idx:Integer dir:( _ d:(ASC_K / DESC_K) { return string(c.text), nil } )? {
    return buildOrderByItem(idx, dir), nil
}

LimitClause <- _ LIMIT_K _ n:Integer {
    return buildLimitClause(n), nil
}

// ============================================================================
// Expressions (precedence from lowest to highest)
// ============================================================================

Expr <- OrExpr

OrExpr <- first:AndExpr rest:( _ OR_K _ e:AndExpr { return e, nil } )* {
    return buildBinaryChain(first, rest, "OR"), nil
}

AndExpr <- first:Comparison rest:( _ AND_K _ e:Comparison { return e, nil } )* {
    return buildBinaryChain(first, rest, "AND"), nil
}

Comparison <- left:Additive op:CompOp? right:Additive? {
    return buildComparison(left, op, right), nil
}

CompOp <- _ op:( "<=" / ">=" / "<>" / "!=" / "<" / ">" / "=" ) _ {
    return string(c.text), nil
}

Additive <- first:Multiplicative rest:( _ op:AddOp _ e:Multiplicative { return []interface{}{op, e}, nil } )* {
    return buildAdditiveChain(first, rest), nil
}

AddOp <- op:( '+' / '-' ) {
    return string(c.text), nil
}

Multiplicative <- first:Unary rest:( _ op:MulOp _ e:Unary { return []interface{}{op, e}, nil } )* {
    return buildMultiplicativeChain(first, rest), nil
}

MulOp <- op:( '*' / '/' ) {
    return string(c.text), nil
}

Unary <- op:UnaryOp? _ primary:Primary {
    return buildUnary(op, primary), nil
}

UnaryOp <- op:( NOT_K / '-' ) _ {
    return string(c.text), nil
}

// ============================================================================
// Primary Expressions
// ============================================================================

Primary <- Literal / FunctionCall / ColumnRef / ParenExpr

ParenExpr <- '(' _ expr:Expr _ ')' {
    return expr, nil
}

Literal <- BoolLiteral / StringLiteral / IntLiteral

IntLiteral <- [0-9]+ {
    return buildIntLiteral(string(c.text)), nil
}

StringLiteral <- '\'' content:StringContent '\'' {
    return buildStringLiteral(content), nil
}

StringContent <- ( !'\'' . / "''" )* {
    return string(c.text), nil
}

BoolLiteral <- ( "TRUE"i / "FALSE"i ) {
    return buildBoolLiteral(string(c.text)), nil
}

FunctionCall <- name:FunctionName _ '(' _ args:FunctionArgs? _ ')' {
    return buildFunction(name, args), nil
}

FunctionName <- ( "STRLEN"i / "CONCAT"i / "UPPER"i / "LOWER"i / "REPLACE"i ) {
    return string(c.text), nil
}

FunctionArgs <- first:Expr rest:( _ ',' _ e:Expr { return e, nil } )* {
    return buildArgsList(first, rest), nil
}

ColumnRef <- table:( name:Identifier '.' { return name, nil } )? column:Identifier {
    return buildColumnRef(table, column), nil
}

// ============================================================================
// Lexical Elements
// ============================================================================

// Keyword tokens with explicit word-boundary check to avoid matching prefixes
SELECT_K <- "SELECT"i ![a-zA-Z0-9_] { return string(c.text), nil }
FROM_K   <- "FROM"i   ![a-zA-Z0-9_] { return string(c.text), nil }
WHERE_K  <- "WHERE"i  ![a-zA-Z0-9_] { return string(c.text), nil }
ORDER_K  <- "ORDER"i  ![a-zA-Z0-9_] { return string(c.text), nil }
BY_K     <- "BY"i     ![a-zA-Z0-9_] { return string(c.text), nil }
ASC_K    <- "ASC"i    ![a-zA-Z0-9_] { return string(c.text), nil }
DESC_K   <- "DESC"i   ![a-zA-Z0-9_] { return string(c.text), nil }
LIMIT_K  <- "LIMIT"i  ![a-zA-Z0-9_] { return string(c.text), nil }
AND_K    <- "AND"i    ![a-zA-Z0-9_] { return string(c.text), nil }
OR_K     <- "OR"i     ![a-zA-Z0-9_] { return string(c.text), nil }
NOT_K    <- "NOT"i    ![a-zA-Z0-9_] { return string(c.text), nil }
TRUE_K   <- "TRUE"i   ![a-zA-Z0-9_] { return string(c.text), nil }
FALSE_K  <- "FALSE"i  ![a-zA-Z0-9_] { return string(c.text), nil }

STRLEN_K <- "STRLEN"i ![a-zA-Z0-9_] { return string(c.text), nil }
CONCAT_K <- "CONCAT"i ![a-zA-Z0-9_] { return string(c.text), nil }
REPLACE_K <- "REPLACE"i ![a-zA-Z0-9_] { return string(c.text), nil }
UPPER_K  <- "UPPER"i  ![a-zA-Z0-9_] { return string(c.text), nil }
LOWER_K  <- "LOWER"i  ![a-zA-Z0-9_] { return string(c.text), nil }

Identifier <- !ReservedWord [a-zA-Z_] [a-zA-Z0-9_]* {
    return string(c.text), nil
}

ReservedWord <- ( SELECT_K / FROM_K / WHERE_K / ORDER_K / BY_K / ASC_K / DESC_K / 
                 LIMIT_K / AND_K / OR_K / NOT_K / TRUE_K / FALSE_K /
                 STRLEN_K / CONCAT_K / UPPER_K / LOWER_K / REPLACE_K )

Integer <- [0-9]+ {
    return parseInt(string(c.text)), nil
}

_ "whitespace" <- [ \t\n\r]*

EOF <- !.
